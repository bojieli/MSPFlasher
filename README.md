# 编译运行

1. 新建 Visual Studio 工程
2. 选择控制台工程，不要使用预编译头（stdafx）
3. 将 flash.c 加入工程
4. 选择 Release 模式，编译
5. 将 resource 文件夹复制到 Release 文件夹
6. 双击运行 Release 文件夹中的 flash.exe

在 cygwin 下编译的方法（不推荐）：make，生成 flash.exe，这样生成的程序需要有 cygwin1.dll 才能运行。

# 烧写说明

如果不是第一次烧写，需要把 id.txt 文件放在与 flash.exe 相同的目录中。这个文件包括所有已经烧写过的ID，用于保证随机生成的ID不冲突。

当命令行提示 "Press ENTER to flash next" 时，换上新的一片待烧写芯片，回车，就会开始烧写。

烧写完成后，按 Ctrl+C 退出，保存好 id.txt 文件以便下次烧写使用。

# Card ID

Card ID 由9个字节构成。

前两个字节是产品类型和产品批号。它们硬编码在 ```flash.c``` 的宏里，分别是 ```PRODUCT_TYPE``` 和 ```PRODUCT_VERSION```。

产品类型在同种产品中保持一致，0x00 留作测试，0x01 代表电子学生证。以后做物联网的时候，可能需要不同种类的产品之间互联，这一字节就派上用场了。

产品批号代表生产这种产品的批次，0x00 留作测试，0x01 代表第一次生产，0x02 代表第二次生产，以此类推（假定生产次数不超过255）。这样，当射频卡出现问题时，我们就可以根据这个字段定位是哪次生产的产品，进而定位是软件、硬件还是制造商的问题。原则上每次生产都要增加这一字段，增加后需要重新编译。

第 2～7 字节（从0开始计数）是随机字节。因此每个生产批次总共有 2^48 个唯一卡号。假定每批生产不超过 2^20 （约100万个），则平均 2^28 （2.7亿）个可能的ID中才被占用一个，几乎是无法猜测的。

第 8 字节是校验和，采用异或校验：

```id[8] = id[0] ^ id[1] ^ ... ^ id[7]```

因此可以用下式校验 Card ID 的合法性：

```id[0] ^ id[1] ^ ... ^ id[8] == 0```

